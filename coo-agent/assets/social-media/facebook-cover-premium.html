<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>LioraTech Facebook Cover - Premium</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            text-align: center;
        }
        #container {
            margin: 20px auto;
        }
        button {
            background: #1e3a8a;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background: #0f172a;
        }
        #status {
            margin: 20px;
            color: #64748b;
        }
        h1 {
            color: #0f172a;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <h1>LioraTech - Premium Design</h1>
    <div style="color: #64748b; margin: 20px;">World-class execution</div>
    <div id="status">Smelltu á takkann til að vista</div>
    <button onclick="downloadPNG()">Vista sem PNG</button>
    <button onclick="downloadJPG()">Vista sem JPG</button>

    <div id="container">
        <canvas id="canvas" width="1640" height="624"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        drawCover();

        function drawCover() {
            // Premium gradient background
            const bgGradient = ctx.createLinearGradient(0, 0, 1640, 624);
            bgGradient.addColorStop(0, '#0f172a');
            bgGradient.addColorStop(0.4, '#1e3a8a');
            bgGradient.addColorStop(1, '#2563eb');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, 1640, 624);

            // Subtle noise texture overlay for depth
            for (let i = 0; i < 3000; i++) {
                const x = Math.random() * 1640;
                const y = Math.random() * 624;
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.02})`;
                ctx.fillRect(x, y, 1, 1);
            }

            // === LEFT: COMPLEXITY (Sophisticated fragmented state) ===
            ctx.save();
            const leftX = 280;
            const leftY = 312;

            // Create abstract fragmented grid - representing complexity
            const gridSize = 15;
            const gridCells = 8;

            for (let row = 0; row < gridCells; row++) {
                for (let col = 0; col < gridCells; col++) {
                    if (Math.random() > 0.3) {
                        const x = leftX - (gridCells * gridSize) / 2 + col * gridSize;
                        const y = leftY - (gridCells * gridSize) / 2 + row * gridSize;

                        const opacity = 0.1 + Math.random() * 0.15;
                        const offset = Math.random() * 3 - 1.5;

                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.fillRect(x + offset, y + offset, gridSize - 2, gridSize - 2);
                    }
                }
            }

            // Overlapping translucent circles for depth
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const radius = 25 + i * 3;
                const x = leftX + Math.cos(angle) * 30;
                const y = leftY + Math.sin(angle) * 30;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(147, 197, 253, ${0.08 - i * 0.01})`;
                ctx.fill();
            }

            ctx.restore();

            // === CENTER: TRANSFORMATION (Elegant flow visualization) ===
            ctx.save();
            const centerX = 820;
            const centerY = 312;

            // Central node - sophisticated glow
            const nodeGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80);
            nodeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            nodeGradient.addColorStop(0.5, 'rgba(147, 197, 253, 0.2)');
            nodeGradient.addColorStop(1, 'rgba(59, 130, 246, 0)');

            ctx.fillStyle = nodeGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
            ctx.fill();

            // Inner core
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 12, 0, Math.PI * 2);
            ctx.fill();

            // Orbital rings - representing processing/automation
            for (let i = 0; i < 3; i++) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.15 - i * 0.03})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 35 + i * 18, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Flowing particles from left to center
            for (let i = 0; i < 12; i++) {
                const progress = i / 12;
                const x = leftX + (centerX - leftX) * progress;
                const y = leftY + (centerY - leftY) * progress + Math.sin(progress * Math.PI * 2) * 20;

                const size = 2 + Math.sin(progress * Math.PI) * 3;
                const opacity = 0.2 + Math.sin(progress * Math.PI) * 0.3;

                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // === RIGHT: OPTIMIZATION (Elegant upward flow) ===
            ctx.save();
            const rightX = 1360;
            const rightY = 450;

            // Smooth bezier curve showing growth
            const points = [];
            for (let i = 0; i < 8; i++) {
                points.push({
                    x: rightX - 140 + i * 35,
                    y: rightY - (i * i * 3.5) - 20
                });
            }

            // Glow under curve
            const curveGradient = ctx.createLinearGradient(rightX - 140, rightY, rightX + 100, rightY - 200);
            curveGradient.addColorStop(0, 'rgba(147, 197, 253, 0)');
            curveGradient.addColorStop(1, 'rgba(147, 197, 253, 0.15)');

            ctx.fillStyle = curveGradient;
            ctx.beginPath();
            ctx.moveTo(points[0].x, rightY);
            for (let i = 0; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            ctx.lineTo(points[points.length - 1].x, rightY);
            ctx.lineTo(points[0].x, rightY);
            ctx.fill();

            // Main curve line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 0; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            ctx.quadraticCurveTo(
                points[points.length - 2].x,
                points[points.length - 2].y,
                points[points.length - 1].x,
                points[points.length - 1].y
            );
            ctx.stroke();

            // Points on curve
            points.forEach((point, i) => {
                const size = 3 + (i / points.length) * 2;
                const opacity = 0.3 + (i / points.length) * 0.5;

                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Flowing particles from center to right
            for (let i = 0; i < 12; i++) {
                const progress = i / 12;
                const x = centerX + (rightX - 100 - centerX) * progress;
                const y = centerY + (rightY - 100 - centerY) * progress - Math.sin(progress * Math.PI) * 30;

                const size = 2 + Math.sin(progress * Math.PI) * 3;
                const opacity = 0.2 + Math.sin(progress * Math.PI) * 0.3;

                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Elegant endpoint glow
            const lastPoint = points[points.length - 1];
            const endGradient = ctx.createRadialGradient(lastPoint.x, lastPoint.y, 0, lastPoint.x, lastPoint.y, 40);
            endGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            endGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = endGradient;
            ctx.beginPath();
            ctx.arc(lastPoint.x, lastPoint.y, 40, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function downloadPNG() {
            const link = document.createElement('a');
            link.download = 'LioraTech-Facebook-Cover-Premium-1640x624.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            document.getElementById('status').textContent = '✓ PNG skrá vistuð!';
            document.getElementById('status').style.color = '#15803d';
        }

        function downloadJPG() {
            const link = document.createElement('a');
            link.download = 'LioraTech-Facebook-Cover-Premium-1640x624.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.95);
            link.click();
            document.getElementById('status').textContent = '✓ JPG skrá vistuð!';
            document.getElementById('status').style.color = '#15803d';
        }
    </script>
</body>
</html>
